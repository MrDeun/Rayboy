\documentclass{article}

% Language setting
% Replace `english' with e.g. `spanish' to change the document language
\usepackage[polish]{babel}
\usepackage[T1]{fontenc}
% Set page size and margins
% Replace `letterpaper' with `a4paper' for UK/EU standard size
\usepackage[a4paper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}
\usepackage{url}

\usepackage[backend=biber,style=numeric]{biblatex}
\addbibresource{bibblo.bib}
% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}

\title{Niskopoziomowa emulacja sprzętowa implementacja architekturę systemową konsoli Game Boy}
\author{Patryk Michalak}




\begin{document}
	\maketitle
	
	\begin{abstract}
		Your abstract.
	\end{abstract}
	
\clearpage
	\tableofcontents
	\clearpage
\section{Wstęp}

\subsection{Opis problemu}

Konsola \textit{Game Boy}, wyprodukowana przez firmę \textit{Nintendo} i wprowadzona na rynek japoński 21 kwietnia 1989 roku, stała się jednym z najbardziej rozpoznawalnych urządzeń w historii elektronicznej rozrywki. Game Boy odniosła znaczący sukces komercyjny – w ciągu pierwszych lat od premiery sprzedano ponad 20 milionów egzemplarzy. W kolejnych latach konsola została wprowadzona na rynki zachodnie, gdzie również zdobyła dużą popularność. Łączna sprzedaż wszystkich wariantów urządzenia uczyniła ją jedną z najlepiej sprzedających się konsol przenośnych w historii.

Gry dla konsoli były dystrybuowane w postaci wymiennych kartridży (Game Pak), zawierających pamięć ROM z kodem programu, danymi graficznymi oraz dźwiękowymi. W niektórych przypadkach kartridże wyposażone były dodatkowo w pamięć RAM oraz baterię podtrzymującą stan gry. Architektura sprzętowa konsoli opierała się na 8-bitowym procesorze taktowanym częstotliwością około 4,19 MHz, a obraz generowany był w rozdzielczości 160×144 pikseli przy czterech poziomach szarości.

Wraz z zakończeniem produkcji konsoli przez \textit{Nintendo} dostęp do oryginalnego sprzętu stał się ograniczony. Znaczna część tytułów wydanych wyłącznie na tę platformę nie została oficjalnie przeniesiona na nowsze systemy. W konsekwencji wiele gier pozostaje dostępnych jedynie poprzez zachowane egzemplarze konsoli oraz kartridże, co utrudnia ich użytkowanie oraz archiwizację.

\subsection{Emulatory}

Jednym z rozwiązań problemu ograniczonej dostępności oryginalnego sprzętu są emulatory, czyli programy komputerowe umożliwiające odtworzenie funkcjonalności danego systemu sprzętowego w środowisku wirtualnym. Emulator odwzorowuje działanie procesora, pamięci, układów graficznych oraz urządzeń wejścia/wyjścia w sposób pozwalający na uruchamianie oryginalnego oprogramowania.

Emulatory znajdują zastosowanie nie tylko w środowisku graczy, lecz również w badaniach nad architekturą systemów komputerowych, analizie kompatybilności oprogramowania oraz cyfrowej archiwizacji dziedzictwa technologicznego. Umożliwiają one zachowanie historycznej wartości gier i systemów, które w przeciwnym razie mogłyby zostać utracone wraz z degradacją fizycznych nośników.

Wyróżnia się dwa podstawowe podejścia do emulacji:
\begin{itemize}
	\item \textbf{Emulacja pełna} – polegająca na wiernym odwzorowaniu wszystkich kluczowych komponentów sprzętowych systemu, w tym procesora, pamięci, grafiki oraz dźwięku.
	\item \textbf{Emulacja częściowa} – obejmująca jedynie wybrane elementy systemu, co może ograniczać kompatybilność z oryginalnym oprogramowaniem.
\end{itemize}

W kontekście niniejszej pracy przyjęto założenie realizacji emulacji pełnej w zakresie podstawowej funkcjonalności konsoli.

\subsection{Założenia i cel pracy}

Celem niniejszej pracy jest zaprojektowanie oraz implementacja emulatora konsoli Game Boy w języku programowania C++, z wykorzystaniem biblioteki Raylib do obsługi warstwy graficznej i wejścia użytkownika. Projekt zakłada odwzorowanie podstawowych mechanizmów działania oryginalnej architektury sprzętowej w stopniu umożliwiającym uruchamianie wybranej klasy gier.

Zakres pracy obejmuje:
\begin{itemize}
	\item implementację emulacji procesora oraz mapy pamięci konsoli,
	\item odwzorowanie mechanizmu wyświetlania obrazu,
	\item obsługę wejścia użytkownika z wykorzystaniem klawiatury,
	\item możliwość wczytywania obrazów ROM typu \textit{ROM Only},
	\item zapewnienie wieloplatformowości (Windows, Linux, macOS).
\end{itemize}

W ramach projektu przyjęto ograniczenie do obsługi podstawowego typu kartridża zawierającego wyłącznie pamięć ROM, bez dodatkowych kontrolerów pamięci (MBC). Emulator przeznaczony jest do uruchamiania cyfrowych kopii gier pozyskanych przez użytkownika z posiadanych nośników.

Poprawność działania systemu zostanie zweryfikowana poprzez porównanie wyników emulacji z publicznie dostępnymi testami zgodności opracowanymi przez społeczność dokumentującą architekturę konsoli.

\subsection{Grupa docelowa}

Odbiorcami opracowanego systemu są użytkownicy posiadający legalne kopie gier przeznaczonych na konsolę Game Boy, zainteresowani ich uruchamianiem na współczesnych komputerach osobistych. Emulator może stanowić również narzędzie edukacyjne dla osób zainteresowanych architekturą systemów wbudowanych oraz mechanizmami niskopoziomowego działania sprzętu.
\section{Analiza architektury systemowej konsoli Game Boy}
\subsection{Specyfikacja techniczna}
Nintendo Research And Development 1, pod przewodnictwem Gunpei Yokoi i Satoru Okady, zaprojektowało 8-bitową konsolę Game Boya. Charakteryzuje się wyświetlaczem matrycowym o rozdzielczości 160x144 pikseli, D-padem, czterema przyciskami gry i jednym głośnikiem. Używa stworzonych na potrzebe konsoli kartridże `GamePak`. Zasilany był przez 4 baterie AA. Gracze mogli korzystać z kabla Game Link Cable do połączenia dwóch Game Boyów dla rozgrywki wieloosobowej bądź transferu danych dla wspierających gier. Chociaż wyświetlacz monochromatyczny był gorszy niż u konkurencji, umożliwił on bardziej tanie i długotrwałe życie baterii. `\cite{wikipedia-gameboy}`
\subsection{Procesor i SoC}
Procesorem Gameboya był specjalnie wytworzyny na potrzeby konsoli  8-bitowy procesor SM83 firmy Sharp. \cite{gbctr}. Procesor był mieszanką dwóch innych procesorów - 8080 firmy Intel i Z80 firmy Zilog. Procesor znajdował się na płytce wraz innymi komponentami takimi jak pamięć RAM i ROM. Cała płytka jest określana jako SoC (System on Chip) i oryginalny Game Boy zawierał DMG-CPU znany także jako Sharp LR35902 \cite{copetti}. SoC był wpinany do płyty głównej, która zawierała dodatkową pamięć RAM i Video RAM (VRAM) jak i łączyła się z innymi kompomentami jak ekran, głośnik czy kontroler. 
\subsubsection{Model czasowy systemu}

Działanie konsoli Game Boy oparte jest na synchronicznym modelu czasowym, w którym wszystkie główne komponenty systemu --- procesor, układ graficzny oraz timery sprzętowe --- pracują w oparciu o wspólne źródło taktowania. Nominalna częstotliwość zegara systemowego wynosi $4{,}194304$~MHz, co determinuje tempo wykonywania instrukcji procesora oraz przebieg cykli pracy pozostałych bloków funkcjonalnych.

\paragraph{Cykle maszynowe procesora}

Procesor wykonuje instrukcje w jednostkach zwanych cyklami maszynowymi (ang. \emph{machine cycles}), z których każdy obejmuje określoną liczbę taktów zegara systemowego. Czas wykonania instrukcji zależy od jej złożoności i wynosi zazwyczaj od jednego do kilku cykli maszynowych. Model czasowy procesora ma charakter deterministyczny, co oznacza, że liczba cykli wymaganych do wykonania danej instrukcji jest stała i niezależna od kontekstu wykonania.

\paragraph{Synchronizacja z układem graficznym}

Układ graficzny pracuje równolegle z procesorem i cyklicznie przechodzi przez zdefiniowane fazy generowania obrazu. Każda ramka obrazu składa się z sekwencji linii skanowania, a przebieg ich przetwarzania wyznacza rytm pracy całego systemu. W określonych fazach generowania obrazu dostęp procesora do wybranych obszarów pamięci wideo jest ograniczony, co stanowi bezpośrednią konsekwencję współdzielenia zasobów pamięci pomiędzy jednostkami systemu.

\paragraph{System timerów sprzętowych}

Konsola wyposażona jest w sprzętowe układy odmierzania czasu, których działanie jest bezpośrednio powiązane z zegarem systemowym. Timery te generują zdarzenia okresowe wykorzystywane do synchronizacji logiki programu, pomiaru czasu oraz inicjowania przerwań sprzętowych. Ich konfiguracja pozwala na wybór różnych częstotliwości zliczania poprzez dzielenie sygnału zegarowego.

\paragraph{Znaczenie modelu czasowego}

Ścisłe powiązanie pracy wszystkich komponentów z jednym źródłem taktowania zapewnia deterministyczny charakter działania systemu. W konsekwencji poprawność działania oprogramowania zależy nie tylko od sekwencji wykonywanych instrukcji, lecz również od ich dokładnego rozmieszczenia w czasie względem zdarzeń sprzętowych. Model czasowy stanowi zatem istotny element architektury systemowej konsoli i odgrywa kluczową rolę w implementacji wiernych emulatorów platformy.
%
Procesor zawiera osiem 8-bitowych rejestrów: A,B,C,D,E,F,H,L. Rejestry mogą łączyć się w 16-bitowe rejestry: AF, BC, DE, HL . Rejestr F jest używany jako flagi procesora w wypadku operacji arymetycznych:
\begin{itemize}
	\item Bit 7 - Zero (Z), jeśli operacja zwróciła zero
	\item Bit 6 -  Negacja (N), używana gdy ostatnia operacją była porównaniem bądź odejmowaniem
	\item Bit 5 - Half Carry (H), jeśli doszło do przesunięcia na bicie 3
	\item Bit 4 - Carry (C), jeśli doszło do przesunięcia na bicie 7
\end{itemize} 

Bity od 3 do 0 są nieużywane i zawsze powinny być zerowane. Rejestr A jest używany jako akumulator w operacja arytmetcznych.

\subsection{Zestaw Instrukcji}

Zestaw rozkazów (instruction set architecture, ISA) stanowi rozwinięcie koncepcji znanych z mikroprocesorów rodziny Z80, z licznymi uproszczeniami i modyfikacjami dostosowanymi do zastosowań w systemie przenośnym. Wszytkie rozkazy można systematycznie sklasyfikować na poszczególne grupy .

\begin{figure}[htbp]
	\centering
	\begin{minipage}{0.9\textwidth}
		\centering
		\includegraphics[width=0.9\linewidth]{gbobtables.png}
		\caption{Tablica rozmieszczenia instrukcji: \cite{opcodes}}
		\label{fig:op_table}
	\end{minipage}
	\hfill
	\begin{minipage}{0.9\textwidth}
		\centering
		\includegraphics[width=0.9\linewidth]{gbobtables_cb.png}
		\caption{Tablica rozmieszczenia instrukcji po opcodzie 0xCB: \cite{opcodes}}
		\label{fig:opcb_table}
	\end{minipage}
\end{figure}

\subsubsection{Instrukcje transferu danych}

Instrukcje tej grupy odpowiadają za przemieszczanie informacji pomiędzy rejestrami, pamięcią oraz natychmiastowymi wartościami liczbowymi. Do najważniejszych operacji należą:

\begin{itemize}
	\item \textbf{LD (Load)} -- realizuje kopiowanie danych pomiędzy rejestrami ogólnego przeznaczenia (A, B, C, D, E, H, L), parami rejestrów oraz komórkami pamięci adresowanymi bezpośrednio lub pośrednio.
	\item \textbf{LDH} -- specjalizowana forma transferu do i z obszaru pamięci o wysokim adresie (High RAM).
	\item \textbf{PUSH / POP} -- zapis i odczyt danych na stosie, z wykorzystaniem wskaźnika stosu SP.
\end{itemize}

Instrukcje transferu nie modyfikują danych źródłowych (z wyjątkiem operacji stosowych), a ich podstawową funkcją jest reorganizacja informacji w przestrzeni rejestrowo-pamięciowej procesora.

\subsubsection{Instrukcje arytmetyczne}

Instrukcje arytmetyczne realizują operacje matematyczne na liczbach całkowitych. W SM83 operacje te wykonywane są głównie na akumulatorze A. Do kluczowych operacji należą:

\begin{itemize}
	\item \textbf{ADD / ADC} -- dodawanie bez i z uwzględnieniem flagi przeniesienia,
	\item \textbf{SUB / SBC} -- odejmowanie bez i z uwzględnieniem przeniesienia,
	\item \textbf{INC / DEC} -- inkrementacja i dekrementacja rejestrów oraz komórek pamięci,
	\item \textbf{DAA} -- korekcja wyniku dodawania do postaci BCD,
	\item \textbf{CP} -- porównanie wartości bez zapisu wyniku (modyfikowane są jedynie flagi).
\end{itemize}

Instrukcje te aktualizują rejestr flag (Z, N, H, C), który odzwierciedla właściwości wyniku operacji.

\subsubsection{Instrukcje logiczne i bitowe}

Grupa ta obejmuje operacje algebry Boole’a oraz manipulacje pojedynczymi bitami. Do najważniejszych należą:

\begin{itemize}
	\item \textbf{AND, OR, XOR} -- operacje logiczne na akumulatorze,
	\item \textbf{CPL} -- negacja bitowa zawartości akumulatora,
	\item \textbf{BIT} -- test wybranego bitu,
	\item \textbf{SET / RES} -- ustawienie lub wyzerowanie wskazanego bitu.
\end{itemize}

Instrukcje bitowe umożliwiają precyzyjną kontrolę struktur danych, co jest szczególnie istotne w systemach o ograniczonych zasobach pamięci.

\subsubsection{Instrukcje przesunięć i rotacji}

Operacje tej kategorii realizują przesunięcia bitowe oraz rotacje z lub bez udziału flagi przeniesienia:

\begin{itemize}
	\item \textbf{RL, RLC} -- rotacja w lewo,
	\item \textbf{RR, RRC} -- rotacja w prawo,
	\item \textbf{SLA, SRA, SRL} -- przesunięcia arytmetyczne i logiczne,
	\item \textbf{SWAP} -- zamiana półbajtów w rejestrze.
\end{itemize}

Instrukcje te są użyteczne zarówno w obliczeniach arytmetycznych, jak i w przetwarzaniu danych binarnych.

\subsubsection{Instrukcje sterowania przepływem programu}

Instrukcje sterujące odpowiadają za zmianę kolejności wykonywania programu:

\begin{itemize}
	\item \textbf{JP} -- skok bezwarunkowy lub warunkowy,
	\item \textbf{JR} -- skok względny o ograniczonym zasięgu,
	\item \textbf{CALL / RET} -- wywołanie i powrót z podprogramu,
	\item \textbf{RST} -- szybkie wywołanie procedury o stałym adresie.
\end{itemize}

Warunkowość operacji zależy od stanu flag procesora, co umożliwia implementację struktur decyzyjnych.

Do tej grupy należą instrukcje wpływające na stan globalny procesora:

\begin{itemize}
	\item \textbf{NOP} -- brak operacji,
	\item \textbf{HALT} -- zatrzymanie pracy CPU do momentu wystąpienia przerwania,
	\item \textbf{STOP} -- tryb niskiego poboru energii,
	\item \textbf{DI / EI} -- dezaktywacja i aktywacja systemu przerwań,
	\item \textbf{SCF / CCF} -- manipulacja flagą przeniesienia.
\end{itemize}

Instrukcje te mają kluczowe znaczenie dla zarządzania energią oraz obsługi zdarzeń asynchronicznych.


\subsection{Mapowanie pamięci w konsoli Game Boy}

Architektura pamięci konsoli Game Boy oparta jest na 16-bitowej przestrzeni adresowej o rozmiarze $2^{16} = 65\,536$ bajtów (64~KB). Procesor systemu, zgodny z modyfikowaną architekturą Sharp LR35902, wykorzystuje jednolitą przestrzeń adresową, w której różne zakresy adresów są przypisane do odmiennych typów pamięci oraz rejestrów sprzętowych. Taki model organizacji pamięci określany jest jako \emph{memory-mapped I/O} i umożliwia bezpośrednią komunikację procesora z układami peryferyjnymi poprzez operacje odczytu i zapisu w odpowiednich obszarach adresowych.

\subsubsection{Ogólny układ przestrzeni adresowej}

Przestrzeń adresowa Game Boya podzielona jest na segmenty o ustalonej funkcji sprzętowej. Tabela~\ref{tab:gb_memory_map} przedstawia standardowy schemat mapowania pamięci.

\begin{table}[h]
	\centering
	\begin{tabular}{lll}
		\hline
		Zakres adresów & Rozmiar & Przeznaczenie \\
		\hline
		\texttt{0000--3FFF} & 16 KB & Stała pamięć ROM banku 0 \\
		\texttt{4000--7FFF} & 16 KB & Przełączalny bank ROM \\
		\texttt{8000--9FFF} & 8 KB  & Pamięć wideo (VRAM) \\
		\texttt{A000--BFFF} & 8 KB  & Zewnętrzna pamięć RAM w kartridżu \\
		\texttt{C000--CFFF} & 4 KB  & Wewnętrzna pamięć robocza (WRAM bank 0) \\
		\texttt{D000--DFFF} & 4 KB  & Wewnętrzna pamięć robocza (bank przełączalny) \\
		\texttt{E000--FDFF} & 7.5 KB & Obszar echo pamięci WRAM \\
		\texttt{FE00--FE9F} & 160 B & Pamięć atrybutów obiektów (OAM) \\
		\texttt{FEA0--FEFF} & 96 B  & Obszar niedostępny \\
		\texttt{FF00--FF7F} & 128 B & Rejestry wejścia/wyjścia \\
		\texttt{FF80--FFFE} & 127 B & Pamięć szybka (HRAM) \\
		\texttt{FFFF}       & 1 B   & Rejestr przerwań (IE) \\
		\hline
	\end{tabular}
	\caption{Mapa pamięci konsoli Game Boy \cite{pandocs}}
	\label{tab:gb_memory_map}
\end{table}

\subsubsection{Pamięć programu i bankowanie ROM}

Dolne 32~KB przestrzeni adresowej przeznaczone jest na pamięć tylko do odczytu (ROM) zawartą w kartridżu. Pierwsze 16~KB (\texttt{0000--3FFF}) stanowi bank stały, natomiast zakres \texttt{4000--7FFF} obsługuje mechanizm przełączania banków pamięci, realizowany przez kontroler MBC (Memory Bank Controller). Dzięki temu możliwe jest adresowanie programów o rozmiarze znacznie przekraczającym 64~KB.

\subsubsection{Pamięć wideo}

Obszar \texttt{8000--9FFF} odpowiada pamięci VRAM, wykorzystywanej przez układ graficzny do przechowywania danych kafelków graficznych oraz map tła. Dostęp do tej pamięci jest ograniczony w określonych fazach cyklu wyświetlania obrazu, co wynika z synchronizacji procesora z kontrolerem LCD.

\subsubsection{Pamięć robocza i obszar echo}

Wewnętrzna pamięć robocza WRAM zajmuje zakres \texttt{C000--DFFF}. Dodatkowo obszar \texttt{E000--FDFF} stanowi tzw. echo WRAM, czyli lustrzane odwzorowanie części pamięci roboczej. Jego obecność wynika z uproszczeń sprzętowych i nie jest zalecana do programowego wykorzystania.

\subsubsection{Mapowanie urządzeń wejścia/wyjścia}

Zakres \texttt{FF00--FF7F} zawiera rejestry sterujące sprzętem, w tym kontrolerem dźwięku, systemem przerwań, timerami oraz interfejsem wejściowym. Operacje zapisu i odczytu w tych adresach odpowiadają bezpośrednim operacjom na urządzeniach peryferyjnych.

\subsubsection{Pamięć wysokiej prędkości}

Obszar \texttt{FF80--FFFE}, określany jako HRAM (High RAM), to niewielki fragment szybkiej pamięci roboczej o krótkim czasie dostępu. Ze względu na swoje właściwości jest on często wykorzystywany do przechowywania zmiennych o krytycznym znaczeniu czasowym.

\subsubsection{Znaczenie architektury mapowania pamięci}

Przyjęty model mapowania pamięci umożliwia efektywne współdzielenie przestrzeni adresowej przez kod programu, dane oraz układy sprzętowe. Rozwiązanie to upraszcza konstrukcję systemu, lecz jednocześnie wymaga ścisłej kontroli dostępu do poszczególnych segmentów pamięci przez oprogramowanie systemowe i aplikacyjne.
\subsection{System przerwań w konsoli Game Boy}

System przerwań w konsoli Game Boy realizuje mechanizm asynchronicznej obsługi zdarzeń sprzętowych, umożliwiając procesorowi reagowanie na zdarzenia wewnętrzne i zewnętrzne bez konieczności ciągłego odpytywania urządzeń peryferyjnych. Architektura ta stanowi kluczowy element synchronizacji pracy jednostki centralnej z układami graficznymi, licznikami czasu oraz interfejsem wejściowym.

\subsubsection{Źródła przerwań}

Konsola Game Boy obsługuje pięć podstawowych źródeł przerwań sprzętowych. Każdemu z nich przypisany jest odrębny wektor przerwania oraz odpowiedni bit w rejestrach sterujących. Zestaw źródeł przerwań przedstawiono w tabeli~\ref{tab:gb_interrupts}.

\begin{table}[h]
	\centering
	\begin{tabular}{lll}
		\hline
		Bit & Nazwa przerwania & Funkcja \\
		\hline
		0 & V-Blank & Zakończenie rysowania ramki obrazu \\
		1 & LCD STAT & Zdarzenia kontrolera LCD \\
		2 & Timer & Przepełnienie timera systemowego \\
		3 & Serial & Zakończenie transmisji szeregowej \\
		4 & Joypad & Zmiana stanu kontrolera wejściowego \\
		\hline
	\end{tabular}
	\caption{Źródła przerwań w konsoli Game Boy\cite{pandocs}}
	\label{tab:gb_interrupts}
\end{table}

Przerwanie V-Blank pełni szczególną rolę, ponieważ wyznacza bezpieczny moment aktualizacji pamięci wideo. Przerwanie LCD STAT umożliwia reakcję na szczegółowe stany pracy kontrolera wyświetlania, natomiast przerwanie timera wykorzystywane jest do odmierzania czasu oraz synchronizacji logiki programu.

\subsubsection{Rejestry sterujące systemem przerwań}

Obsługa przerwań realizowana jest poprzez dwa rejestry mapowane w przestrzeni adresowej:

\begin{itemize}
	\item \texttt{IE} (Interrupt Enable, adres \texttt{FFFF}) --- określa, które źródła przerwań są aktywne.
	\item \texttt{IF} (Interrupt Flag, adres \texttt{FF0F}) --- przechowuje informację o zgłoszonych przerwaniach.
\end{itemize}

Każdy bit w obu rejestrach odpowiada jednemu źródłu przerwania. Zgłoszenie przerwania polega na ustawieniu odpowiedniego bitu w rejestrze \texttt{IF}. Jeżeli odpowiadający mu bit w rejestrze \texttt{IE} jest ustawiony oraz globalna obsługa przerwań jest włączona, procesor inicjuje procedurę obsługi przerwania.

\subsubsection{Mechanizm obsługi przerwania}

Po wykryciu aktywnego przerwania procesor wykonuje następującą sekwencję działań:

\begin{enumerate}
	\item zakończenie bieżącej instrukcji,
	\item zapis aktualnej wartości licznika programu na stosie,
	\item wyłączenie globalnej obsługi przerwań,
	\item skok pod adres wektora przerwania.
\end{enumerate}

Adresy wektorów przerwań są stałe i przypisane do konkretnych źródeł zdarzeń. Po zakończeniu procedury obsługi przerwania wykonywana jest instrukcja powrotu, która przywraca poprzedni stan wykonania programu.

\subsubsection{Priorytety przerwań}

W przypadku jednoczesnego zgłoszenia wielu przerwań stosowany jest ustalony porządek priorytetów. Najwyższy priorytet posiada przerwanie V-Blank, a najniższy przerwanie kontrolera wejściowego. Taki schemat zapewnia deterministyczną obsługę zdarzeń związanych z generowaniem obrazu, które są krytyczne dla poprawnego działania systemu.

\subsubsection{Rola systemu przerwań w architekturze konsoli}

System przerwań stanowi podstawowy mechanizm synchronizacji komponentów sprzętowych konsoli Game Boy. Dzięki niemu możliwe jest efektywne współdziałanie procesora z kontrolerem graficznym, licznikami czasu oraz urządzeniami wejścia/wyjścia przy zachowaniu deterministycznego modelu wykonania programu. Mechanizm ten ma istotne znaczenie zarówno dla projektowania oprogramowania systemowego, jak i dla implementacji emulatorów platformy.

\subsection{Płyta główna}

Płyta główna konsoli Game Boy stanowi podstawowy element konstrukcyjny systemu, integrujący wszystkie kluczowe układy elektroniczne odpowiedzialne za przetwarzanie danych, generowanie obrazu, obsługę dźwięku oraz zarządzanie energią. Ze względu na przenośny charakter urządzenia, konstrukcja płyty została zaprojektowana z naciskiem na energooszczędność, prostotę architektury oraz wysoką niezawodność.

\begin{figure}[htbp]
	\centering
	\begin{minipage}{0.45\textwidth}
		\centering
		\includegraphics[width=0.9\linewidth]{dmg_marked.png}
		\caption{Zdjęcie płyty głównej oryginalnego GameBoy'a z opisami kompomentów\cite{copetti}}
		\label{fig:marked_dmg}
	\end{minipage}
	\hfill
	\begin{minipage}{0.45\textwidth}
		\centering
		\includegraphics[width=0.9\linewidth]{dmg_chart.png}
		\caption{Schemat płyty głównej konsoli GameBoy\cite{copetti}}
		\label{fig:chart_dmg}
	\end{minipage}
\end{figure}

\subsubsection{Jednostka centralna}

Centralnym elementem płyty głównej jest układ DMG-CPU, stanowiący zintegrowany system typu System on Chip (SoC). W przeciwieństwie do klasycznych konstrukcji mikrokomputerowych, w których poszczególne funkcje realizowane są przez oddzielne układy scalone, DMG-CPU integruje w jednej strukturze półprzewodnikowej jednostkę obliczeniową, kontroler pamięci, układ graficzny, generator dźwięku oraz logikę sterującą systemem.

Rdzeń obliczeniowy układu bazuje na architekturze 8-bitowej z 16-bitową przestrzenią adresową i realizuje wykonywanie programu oraz zarządzanie przepływem danych pomiędzy komponentami systemu. Integracja funkcji w jednym układzie pozwoliła na ograniczenie liczby połączeń na płycie głównej, zmniejszenie poboru energii oraz zwiększenie niezawodności urządzenia.

DMG-CPU odpowiada również za synchronizację pracy podsystemów, obsługę przerwań sprzętowych, sterowanie dostępem do pamięci operacyjnej i wideo oraz koordynację komunikacji z interfejsem kartridża i urządzeniami wejścia-wyjścia. Zastosowanie architektury SoC stanowiło kluczowy element miniaturyzacji konsoli oraz umożliwiło osiągnięcie wysokiej efektywności energetycznej przy zachowaniu pełnej funkcjonalności systemu.


\subsubsection{Pamięć operacyjna i pamięć wideo}

Na płycie głównej znajdują się układy pamięci pełniące różne funkcje w architekturze systemu:

\begin{itemize}
	\item \textbf{WRAM (Work RAM)} -- pamięć operacyjna wykorzystywana przez procesor do przechowywania danych roboczych oraz stosu.
	\item \textbf{VRAM (Video RAM)} -- pamięć przeznaczona do przechowywania danych graficznych, takich jak mapy kafli, wzorce znaków oraz informacje o sprite’ach.
\end{itemize}

Pamięci te współpracują bezpośrednio z procesorem oraz układem generowania obrazu, zapewniając sprawną wymianę danych niezbędnych do działania systemu.

\subsubsection{Układ graficzny}

Funkcje generowania obrazu realizowane są przez zintegrowany kontroler LCD, który odpowiada za przetwarzanie danych graficznych i sterowanie wyświetlaczem ciekłokrystalicznym. Układ ten obsługuje system kafli (tile-based graphics), renderowanie sprite’ów oraz synchronizację obrazu z odświeżaniem ekranu. Kontroler LCD współpracuje bezpośrednio z pamięcią wideo oraz procesorem, tworząc kompletny tor przetwarzania grafiki.

\subsubsection{Układ dźwiękowy}

System dźwiękowy konsoli jest zintegrowany z architekturą płyty głównej i składa się z generatorów fal dźwiękowych sterowanych programowo. Układ ten umożliwia generowanie kilku kanałów audio, w tym fal prostokątnych, szumu oraz próbek o ograniczonej rozdzielczości. Sygnał audio kierowany jest następnie do wzmacniacza i głośnika lub wyjścia słuchawkowego. Ze względu skomplikowania, kompoment układu dźwiękowego nie będzie uwzględniany

\subsubsection{Interfejs kartridża}

Na płycie głównej znajduje się złącze kartridża umożliwiające komunikację z zewnętrznym nośnikiem oprogramowania. Interfejs ten zapewnia:

\begin{itemize}
	\item dostęp do pamięci programu,
	\item komunikację z dodatkowymi układami w kartridżu,
	\item możliwość rozszerzenia funkcjonalności systemu.
\end{itemize}

Zastosowanie wymiennych kartridży umożliwiło modularną architekturę systemu oraz łatwą dystrybucję oprogramowania.

\subsubsection{Układy wejścia i wyjścia}

Płyta główna integruje również komponenty odpowiedzialne za komunikację z użytkownikiem oraz otoczeniem:

\begin{itemize}
	\item kontroler przycisków sterujących,
	\item interfejs komunikacyjny (port szeregowy),
	\item sterowanie wyświetlaczem LCD,
	\item wzmacniacz audio.
\end{itemize}

Układy te zapewniają interakcję użytkownika z systemem oraz obsługę sygnałów wejściowych i wyjściowych.

Płyta główna konsoli Game Boy stanowi przykład zwartej i funkcjonalnej integracji elementów elektronicznych w systemie o ograniczonych zasobach sprzętowych. Zastosowanie zintegrowanych układów scalonych, zoptymalizowane zarządzanie energią oraz modułowa struktura pamięci i interfejsów umożliwiły stworzenie wydajnego, przenośnego systemu rozrywkowego. Analiza budowy płyty głównej pozwala dostrzec kompromis pomiędzy funkcjonalnością, energooszczędnością a prostotą konstrukcji, charakterystyczny dla projektowania urządzeń przenośnych końca XX wieku.

\subsection{Kartridże systemu Game Boy}

Kartridże stanowią podstawowy nośnik oprogramowania dla konsoli Game Boy oraz element rozszerzający funkcjonalność systemu. Oprócz pamięci programu zawierają one układy logiczne odpowiedzialne za zarządzanie pamięcią, zapisywanie danych użytkownika oraz, w niektórych przypadkach, dodatkowe funkcje sprzętowe. Różnorodność konstrukcji kartridżów wynikała z konieczności obsługi gier o rosnącej złożoności przy zachowaniu ograniczeń architektury systemu.

\subsubsection{Kartridże bez kontrolera banków pamięci (ROM Only)}

Najprostszy typ kartridża zawiera wyłącznie pamięć ROM z programem gry. Konstrukcja ta nie umożliwia przełączania banków pamięci ani zapisu danych użytkownika. Ze względu na ograniczoną pojemność stosowana była głównie w prostszych produkcjach we wczesnym okresie rozwoju systemu.

\subsubsection{Kartridże z kontrolerem MBC1}

Kontroler Memory Bank Controller 1 (MBC1) umożliwia przełączanie banków pamięci ROM oraz, opcjonalnie, banków pamięci RAM. Układ ten pozwalał na znaczące zwiększenie maksymalnego rozmiaru programu. Kartridże tego typu występowały w kilku wariantach:

\begin{itemize}
	\item MBC1 + RAM,
	\item MBC1 + RAM + bateria podtrzymująca zapis danych.
\end{itemize}

\subsubsection{Kartridże z kontrolerem MBC2}

MBC2 integruje funkcję przełączania banków ROM z niewielką, wbudowaną pamięcią RAM przeznaczoną do zapisu danych gry. W odróżnieniu od innych kontrolerów, pamięć RAM jest integralną częścią układu i nie występuje jako oddzielny komponent. Kartridże te standardowo wyposażone były w baterię podtrzymującą zapis.

\subsubsection{Kartridże z kontrolerem MBC3}

MBC3 rozszerza funkcjonalność poprzednich kontrolerów o zegar czasu rzeczywistego (RTC). Rozwiązanie to umożliwiało implementację mechanik zależnych od upływu czasu rzeczywistego. Warianty konstrukcyjne obejmowały:

\begin{itemize}
	\item MBC3 + RAM,
	\item MBC3 + RAM + bateria,
	\item MBC3 + RAM + bateria + RTC.
\end{itemize}

\subsubsection{Kartridże z kontrolerem MBC5}

MBC5 wprowadza rozszerzony system adresowania pamięci ROM oraz obsługę większych pojemności pamięci RAM. Układ ten był stosowany w późniejszych produkcjach o dużej objętości danych. Warianty obejmowały:

\begin{itemize}
	\item MBC5 + RAM,
	\item MBC5 + RAM + bateria,
	\item MBC5 + RAM + bateria + silnik wibracyjny (Rumble).
\end{itemize}

\subsubsection{Kartridże specjalizowane}

Oprócz standardowych kontrolerów banków pamięci produkowano kartridże wyposażone w dodatkowe układy funkcjonalne rozszerzające możliwości systemu. Do najważniejszych należą:

\begin{itemize}
	\item kartridże z czujnikiem ruchu,
	\item kartridże z pamięcią EEPROM,
	\item kartridże z dodatkowymi układami logicznymi sterującymi akcesoriami,
	\item kartridże diagnostyczne i testowe wykorzystywane w procesie produkcyjnym.
\end{itemize}

\subsubsection{Struktura fizyczna kartridża}

Typowy kartridż składa się z płytki drukowanej zawierającej układ ROM, opcjonalną pamięć RAM, kontroler banków pamięci oraz element podtrzymania zasilania pamięci zapisu. Komunikacja z konsolą odbywa się za pośrednictwem złącza krawędziowego, które zapewnia dostęp do magistrali adresowej, magistrali danych oraz linii sterujących.

\section{Model działania systemu Game Boy}
\subsection{Cykl pracy procesora}

Procesor zastosowany w konsoli Game Boy jest 8-bitową jednostką opartą na zmodyfikowanej architekturze zbliżonej do Z80. Jego działanie jest determinowane przez cykl zegara systemowego oraz mechanizm wykonywania instrukcji w modelu sekwencyjnym. Zrozumienie cyklu pracy procesora jest kluczowe dla analizy działania całego systemu, ponieważ CPU koordynuje komunikację pomiędzy pamięcią, układem graficznym oraz urządzeniami wejścia/wyjścia.

\subsubsection{Model cyklu rozkazowego}

Podstawowy cykl pracy procesora można opisać jako powtarzającą się sekwencję trzech etapów:
\begin{enumerate}
	\item pobranie instrukcji z pamięci,
	\item dekodowanie instrukcji,
	\item wykonanie instrukcji.
\end{enumerate}

W pierwszym etapie procesor odczytuje kod operacji spod adresu wskazywanego przez licznik programu (PC). Następnie licznik programu zostaje inkrementowany, a pobrana wartość trafia do wewnętrznego rejestru instrukcji.

W drugim etapie następuje interpretacja kodu operacji oraz ustalenie wymaganych operandów. Proces dekodowania determinuje, czy instrukcja wymaga dodatkowych danych z pamięci oraz jakie jednostki funkcjonalne procesora zostaną zaangażowane w jej wykonanie.

Trzeci etap obejmuje właściwe wykonanie operacji arytmetycznej, logicznej lub sterującej. W zależności od typu instrukcji może to obejmować operacje na rejestrach, dostęp do pamięci lub zmianę przepływu sterowania programu.

\subsubsection{Synchronizacja z zegarem systemowym}

Procesor pracuje synchronicznie z zegarem systemowym, którego częstotliwość determinuje tempo wykonywania operacji. Każda instrukcja wymaga określonej liczby cykli zegara do wykonania. Czas realizacji instrukcji nie jest stały i zależy od jej złożoności oraz liczby operacji pamięciowych.

Istotnym elementem synchronizacji jest współdzielenie magistrali danych z innymi komponentami systemu. Dostęp do pamięci jest realizowany w ściśle określonych momentach cyklu zegara, co zapewnia spójność transmisji danych pomiędzy CPU a pozostałymi układami.

\subsubsection{Dostęp do pamięci i operacje magistrali}

Procesor komunikuje się z pamięcią poprzez magistralę adresową i magistralę danych. W trakcie cyklu rozkazowego mogą wystąpić operacje odczytu lub zapisu pamięci. Operacje te są wykonywane sekwencyjnie i blokują dostęp do magistrali dla innych komponentów na czas trwania transferu.

Mapowanie pamięci odgrywa istotną rolę w cyklu pracy procesora, ponieważ różne zakresy adresowe odpowiadają różnym typom zasobów systemowych, takim jak pamięć operacyjna, pamięć wideo oraz rejestry sterujące urządzeń peryferyjnych.

\subsubsection{Obsługa przerwań}

Cykl pracy procesora może zostać przerwany przez mechanizm przerwań sprzętowych. Wystąpienie przerwania powoduje czasowe wstrzymanie wykonywania bieżącego programu oraz zapis aktualnego stanu procesora na stosie.

Po zaakceptowaniu przerwania procesor przechodzi do procedury obsługi przerwania wskazanej w tablicy wektorów przerwań. Po zakończeniu obsługi następuje przywrócenie poprzedniego stanu procesora i kontynuacja wykonywania programu od miejsca przerwania.

\subsubsection{Znaczenie cyklu pracy dla działania systemu}

Deterministyczny charakter cyklu pracy procesora umożliwia precyzyjną synchronizację z układem graficznym oraz pozostałymi komponentami systemu. W szczególności liczba cykli zegara zużywana przez instrukcje wpływa bezpośrednio na generowanie obrazu oraz obsługę zdarzeń wejścia/wyjścia.

Analiza cyklu pracy procesora stanowi podstawę do modelowania działania systemu oraz jest niezbędna przy implementacji oprogramowania emulującego działanie konsoli.
\subsection{Magistrala pamięciowa i charakterystyka działania pamięci}

System pamięci konsoli Game Boy opiera się na wspólnej przestrzeni adresowej obsługiwanej przez procesor oraz na zestawie wyspecjalizowanych obszarów pamięci o odmiennych funkcjach. Komunikacja pomiędzy jednostką centralną a zasobami pamięciowymi realizowana jest za pomocą magistrali adresowej, magistrali danych oraz sygnałów sterujących, które determinują kierunek i tryb transferu informacji.

\subsubsection{Organizacja magistrali pamięciowej}

Magistrala adresowa umożliwia wskazanie konkretnej komórki pamięci w przestrzeni adresowej systemu. Procesor generuje adres, który identyfikuje zasób, z którego ma nastąpić odczyt danych lub do którego ma zostać wykonany zapis. Magistrala danych służy do przesyłania właściwych informacji pomiędzy procesorem a wskazanym komponentem systemu.

Operacje pamięciowe są synchronizowane z zegarem systemowym. W każdym cyklu dostępu do pamięci następuje ustalenie adresu, aktywacja sygnału sterującego oraz transfer danych. Ze względu na współdzielenie magistrali przez różne komponenty systemu dostęp do niej jest ściśle kontrolowany, co zapobiega konfliktom transmisji.

\subsubsection{Mapowanie przestrzeni adresowej}

Przestrzeń adresowa systemu jest podzielona na logiczne segmenty odpowiadające różnym typom zasobów sprzętowych. Poszczególne zakresy adresów są przypisane do pamięci programu, pamięci operacyjnej, pamięci wideo oraz rejestrów sterujących urządzeń peryferyjnych.

Mapowanie pamięci pełni funkcję mechanizmu integrującego różnorodne komponenty sprzętowe w jednolitą przestrzeń adresową. Dzięki temu procesor może komunikować się z układami systemowymi za pomocą standardowych operacji odczytu i zapisu, bez konieczności stosowania odrębnych instrukcji wejścia/wyjścia.

\subsubsection{Rodzaje pamięci w systemie}

W architekturze systemu można wyróżnić kilka podstawowych typów pamięci:

\begin{itemize}
	\item pamięć programu (ROM), zawierająca kod wykonywalny oraz dane statyczne,
	\item pamięć operacyjna (RAM), wykorzystywana do przechowywania danych tymczasowych,
	\item pamięć wideo (VRAM), przeznaczona do przechowywania danych graficznych,
	\item rejestry urządzeń peryferyjnych odwzorowane w przestrzeni adresowej.
\end{itemize}

Każdy z wymienionych typów pamięci charakteryzuje się odmiennym przeznaczeniem funkcjonalnym oraz sposobem dostępu. W szczególności pamięć wideo jest współdzielona z układem graficznym, co wprowadza ograniczenia czasowe w dostępie do niej przez procesor.

\subsubsection{Charakterystyka operacji pamięciowych}

Operacje pamięciowe wykonywane przez procesor obejmują odczyt danych, zapis danych oraz transfery blokowe realizowane sekwencyjnie. Czas trwania operacji zależy od rodzaju pamięci oraz liczby cykli zegara wymaganych do realizacji transferu.

Dostęp do pamięci może być ograniczony przez stan systemu, w szczególności przez aktywność układów współdzielących magistralę. W określonych fazach pracy systemu wybrane obszary pamięci mogą być czasowo niedostępne dla procesora lub dostępne jedynie w określonych warunkach synchronizacji.

\subsubsection{Rola systemu pamięci w działaniu konsoli}

Architektura pamięci stanowi podstawę wymiany informacji pomiędzy wszystkimi komponentami systemu. Determinuje ona sposób wykonywania programu, obsługi grafiki oraz komunikacji z urządzeniami wejścia/wyjścia.

Jednolita przestrzeń adresowa oraz deterministyczny model dostępu do pamięci umożliwiają przewidywalne działanie systemu w czasie rzeczywistym. Właściwości te mają istotne znaczenie zarówno dla analizy architektury sprzętowej, jak i dla implementacji oprogramowania odwzorowującego działanie systemu.
\subsection{Generowanie klatki obrazu}

Generowanie obrazu w konsoli Game Boy jest realizowane przez układ graficzny (PPU), który współpracuje z pamięcią wideo oraz pamięcią atrybutów obiektów. Proces ten przebiega cyklicznie i jest ściśle zsynchronizowany z zegarem systemowym oraz działaniem procesora. Obraz powstaje poprzez sekwencyjne renderowanie tła, a następnie nakładanie obiektów ruchomych zapisanych w pamięci OAM.

\subsubsection{Format zapisu grafiki w pamięci VRAM}

Podstawową jednostką reprezentacji obrazu w systemie jest tzw. kafel (ang. tile). Każdy kafel reprezentuje fragment obrazu o wymiarach 8×8 pikseli. Dane kafli przechowywane są w pamięci wideo (VRAM) w postaci uporządkowanej tablicy bajtów.

Każdy wiersz kafla kodowany jest przy użyciu dwóch bajtów, które reprezentują dwubitową informację o kolorze każdego piksela w wierszu. Pierwszy bajt zawiera najmniej znaczące bity wartości koloru, natomiast drugi bajt zawiera bity najbardziej znaczące. Odczyt odpowiadających sobie bitów z obu bajtów pozwala określić indeks koloru dla pojedynczego piksela.

Układ graficzny interpretuje dane kafli na podstawie mapy tła, która przechowuje indeksy kafli oraz ich rozmieszczenie na ekranie. Dzięki temu możliwe jest wielokrotne wykorzystanie tych samych danych graficznych w różnych miejscach obrazu.

\subsubsection{Renderowanie tła}

Proces generowania klatki rozpoczyna się od renderowania tła. Układ graficzny przetwarza mapę tła linia po linii, odczytując odpowiednie indeksy kafli oraz ich dane z pamięci VRAM. Dla każdej linii obrazu wyznaczany jest odpowiedni fragment kafla, który następnie przekształcany jest w wartości kolorów pikseli.

Renderowanie odbywa się w sposób deterministyczny i jest zsynchronizowane z aktualną pozycją skanowania ekranu. W wyniku tego procesu powstaje podstawowa warstwa obrazu, która stanowi bazę dla dalszego etapu renderowania.

\subsubsection{Pamięć OAM i reprezentacja obiektów}

OAM (Object Attribute Memory) jest wyspecjalizowanym obszarem pamięci przeznaczonym do przechowywania informacji o obiektach ruchomych, określanych jako sprite'y. Pamięć ta zawiera zestaw rekordów opisujących właściwości graficzne oraz położenie obiektów wyświetlanych na ekranie.

Każdy wpis w pamięci OAM zawiera:
\begin{itemize}
	\item współrzędną pionową obiektu na ekranie,
	\item współrzędną poziomą obiektu,
	\item indeks kafla opisującego grafikę obiektu,
	\item zestaw atrybutów określających sposób renderowania.
\end{itemize}

Atrybuty obiektu mogą obejmować informacje o priorytecie wyświetlania, odbiciu lustrzanym oraz wyborze palety kolorów. Układ graficzny odczytuje zawartość pamięci OAM podczas procesu generowania obrazu i wykorzystuje ją do nałożenia obiektów na wcześniej wyrenderowane tło.

\subsubsection{Renderowanie obiektów}

Po wygenerowaniu warstwy tła układ graficzny przystępuje do renderowania obiektów zapisanych w pamięci OAM. Dla każdej linii obrazu wybierane są obiekty znajdujące się w jej obszarze, a następnie ich dane graficzne są pobierane z pamięci VRAM.

Renderowanie obiektów polega na nałożeniu ich pikseli na istniejący obraz tła zgodnie z regułami priorytetu. W przypadku kolizji pikseli o różnych źródłach decyzja o widoczności zależy od atrybutów obiektu oraz wartości koloru tła.

\subsubsection{DMA i bezpośredni transfer danych do OAM}

W celu usprawnienia transferu danych do pamięci OAM system wykorzystuje mechanizm DMA (Direct Memory Access). Mechanizm ten umożliwia bezpośrednie kopiowanie bloków danych z określonego obszaru pamięci do pamięci OAM bez konieczności wykonywania instrukcji kopiowania przez procesor.

Transfer DMA polega na automatycznym odczycie kolejnych bajtów ze źródłowego obszaru pamięci oraz ich zapisie do kolejnych komórek pamięci OAM. W trakcie operacji DMA procesor ma ograniczony dostęp do magistrali pamięci, co zapewnia spójność przesyłanych danych.

Zastosowanie mechanizmu bezpośredniego transferu bajtów umożliwia szybkie aktualizowanie danych obiektów, co jest szczególnie istotne w systemach czasu rzeczywistego, gdzie konieczna jest synchronizacja zmian graficznych z generowaniem kolejnych klatek obrazu.

\subsubsection{Znaczenie procesu generowania obrazu}

Proces generowania klatki obrazu stanowi wynik ścisłej współpracy pamięci wideo, pamięci OAM oraz układu graficznego. Deterministyczny charakter renderowania oraz uporządkowany dostęp do danych umożliwiają przewidywalne odwzorowanie stanu systemu graficznego w każdej chwili pracy konsoli.

Zrozumienie sposobu generowania obrazu ma istotne znaczenie dla analizy architektury systemu oraz implementacji oprogramowania emulującego działanie układu graficznego.
\subsection{System przerwań}

Mechanizm przerwań w konsoli Game Boy umożliwia asynchroniczną reakcję procesora na zdarzenia sprzętowe zachodzące w systemie. Zamiast ciągłego odpytywania stanu urządzeń peryferyjnych, procesor może wykonywać program główny, a w momencie wystąpienia określonego zdarzenia przejść do dedykowanej procedury obsługi przerwania. Rozwiązanie to zwiększa efektywność wykorzystania czasu procesora oraz zapewnia deterministyczną obsługę zdarzeń czasowych.

\subsubsection{Warunki występowania przerwań}

Przerwanie może zostać wygenerowane przez układ sprzętowy po spełnieniu określonego warunku logicznego, takiego jak zakończenie operacji wejścia/wyjścia, osiągnięcie zadanego stanu licznika czasowego lub zmiana stanu kontrolera wejściowego. Aby przerwanie zostało obsłużone, muszą zostać spełnione trzy warunki:
\begin{enumerate}
	\item źródło przerwania zgłosi żądanie,
	\item odpowiedni typ przerwania jest odblokowany w rejestrze maskującym,
	\item globalny mechanizm obsługi przerwań w procesorze jest aktywny.
\end{enumerate}

Jeżeli wszystkie warunki są spełnione, procesor kończy wykonywanie bieżącej instrukcji, zapisuje aktualny stan wykonania programu oraz przechodzi do procedury obsługi przerwania.

\subsubsection{Rodzaje przerwań}

System przewiduje zestaw sprzętowych źródeł przerwań odpowiadających kluczowym funkcjom konsoli:
\begin{itemize}
	\item przerwanie synchronizacji pionowej obrazu (V-Blank),
	\item przerwanie związane ze stanem układu graficznego (LCD STAT),
	\item przerwanie licznika czasowego (Timer),
	\item przerwanie zakończenia transmisji szeregowej,
	\item przerwanie kontrolera wejścia użytkownika (Joypad).
\end{itemize}

Każdy typ przerwania posiada przypisany wektor, czyli stały adres w pamięci programu, pod którym rozpoczyna się procedura jego obsługi. Priorytet przerwań jest ustalony sprzętowo i determinuje kolejność ich obsługi w przypadku jednoczesnego wystąpienia kilku zdarzeń.

\subsubsection{Przebieg obsługi przerwania}

Obsługa przerwania przebiega według ściśle określonej sekwencji działań wykonywanych przez procesor:
\begin{enumerate}
	\item zakończenie wykonywania bieżącej instrukcji,
	\item zapis aktualnej wartości licznika programu na stosie,
	\item czasowe zablokowanie dalszych przerwań,
	\item przejście do adresu procedury obsługi przerwania,
	\item wykonanie kodu obsługi zdarzenia,
	\item przywrócenie poprzedniego stanu programu i kontynuacja wykonania.
\end{enumerate}

Zapis stanu programu na stosie umożliwia powrót do przerwanego miejsca po zakończeniu obsługi. Instrukcja powrotu z przerwania przywraca licznik programu oraz ponownie aktywuje globalny mechanizm przerwań.

\subsubsection{Funkcje realizowane przez przerwania}

Przerwania pełnią w systemie rolę mechanizmu synchronizującego działanie procesora z procesami zachodzącymi w układach peryferyjnych. Do najważniejszych funkcji realizowanych za ich pomocą należą:
\begin{itemize}
	\item synchronizacja zmian graficznych z cyklem generowania obrazu,
	\item odmierzanie czasu oraz generowanie zdarzeń okresowych,
	\item obsługa transmisji danych pomiędzy komponentami systemu,
	\item reagowanie na działania użytkownika.
\end{itemize}

W szczególności przerwanie synchronizacji pionowej umożliwia bezpieczną aktualizację danych graficznych w pamięci wideo w momentach, gdy układ graficzny nie odczytuje danych do generowania obrazu. Mechanizm przerwań zapewnia tym samym spójność danych oraz stabilność działania systemu w czasie rzeczywistym.

\subsubsection{Znaczenie mechanizmu przerwań}

Zastosowanie przerwań pozwala na efektywne zarządzanie współbieżnymi zdarzeniami w systemie o ograniczonych zasobach sprzętowych. Deterministyczna obsługa zdarzeń oraz priorytetyzacja źródeł przerwań stanowią podstawę prawidłowego działania konsoli oraz umożliwiają implementację oprogramowania wymagającego precyzyjnej synchronizacji czasowej.
\printbibliography
	

\end{document}
