\documentclass{article}

% Language setting
% Replace `english' with e.g. `spanish' to change the document language
\usepackage[polish]{babel}
\usepackage[T1]{fontenc}
% Set page size and margins
% Replace `letterpaper' with `a4paper' for UK/EU standard size
\usepackage[a4paper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}
\usepackage{url}

\usepackage[backend=biber,style=numeric]{biblatex}
\addbibresource{bibblo.bib}
% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}

\title{Niskopoziomowa emulacja sprzętowa implementacja architekturę systemową konsoli Game Boy}
\author{Patryk Michalak}




\begin{document}
	\maketitle
	
	\begin{abstract}
		Your abstract.
	\end{abstract}
	
\clearpage
	\tableofcontents
	\clearpage
\section{Wstęp}

\subsection{Opis problemu}

Konsola \textit{Game Boy}, wyprodukowana przez firmę \textit{Nintendo} i wprowadzona na rynek japoński 21 kwietnia 1989 roku, stała się jednym z najbardziej rozpoznawalnych urządzeń w historii elektronicznej rozrywki. Game Boy odniosła znaczący sukces komercyjny – w ciągu pierwszych lat od premiery sprzedano ponad 20 milionów egzemplarzy. W kolejnych latach konsola została wprowadzona na rynki zachodnie, gdzie również zdobyła dużą popularność. Łączna sprzedaż wszystkich wariantów urządzenia uczyniła ją jedną z najlepiej sprzedających się konsol przenośnych w historii.

Gry dla konsoli były dystrybuowane w postaci wymiennych kartridży (Game Pak), zawierających pamięć ROM z kodem programu, danymi graficznymi oraz dźwiękowymi. W niektórych przypadkach kartridże wyposażone były dodatkowo w pamięć RAM oraz baterię podtrzymującą stan gry. Architektura sprzętowa konsoli opierała się na 8-bitowym procesorze taktowanym częstotliwością około 4,19 MHz, a obraz generowany był w rozdzielczości 160×144 pikseli przy czterech poziomach szarości.

Wraz z zakończeniem produkcji konsoli przez \textit{Nintendo} dostęp do oryginalnego sprzętu stał się ograniczony. Znaczna część tytułów wydanych wyłącznie na tę platformę nie została oficjalnie przeniesiona na nowsze systemy. W konsekwencji wiele gier pozostaje dostępnych jedynie poprzez zachowane egzemplarze konsoli oraz kartridże, co utrudnia ich użytkowanie oraz archiwizację.

\subsection{Emulatory}

Jednym z rozwiązań problemu ograniczonej dostępności oryginalnego sprzętu są emulatory, czyli programy komputerowe umożliwiające odtworzenie funkcjonalności danego systemu sprzętowego w środowisku wirtualnym. Emulator odwzorowuje działanie procesora, pamięci, układów graficznych oraz urządzeń wejścia/wyjścia w sposób pozwalający na uruchamianie oryginalnego oprogramowania.

Emulatory znajdują zastosowanie nie tylko w środowisku graczy, lecz również w badaniach nad architekturą systemów komputerowych, analizie kompatybilności oprogramowania oraz cyfrowej archiwizacji dziedzictwa technologicznego. Umożliwiają one zachowanie historycznej wartości gier i systemów, które w przeciwnym razie mogłyby zostać utracone wraz z degradacją fizycznych nośników.

Wyróżnia się dwa podstawowe podejścia do emulacji:
\begin{itemize}
	\item \textbf{Emulacja pełna} – polegająca na wiernym odwzorowaniu wszystkich kluczowych komponentów sprzętowych systemu, w tym procesora, pamięci, grafiki oraz dźwięku.
	\item \textbf{Emulacja częściowa} – obejmująca jedynie wybrane elementy systemu, co może ograniczać kompatybilność z oryginalnym oprogramowaniem.
\end{itemize}

W kontekście niniejszej pracy przyjęto założenie realizacji emulacji pełnej w zakresie podstawowej funkcjonalności konsoli.

\subsection{Założenia i cel pracy}

Celem niniejszej pracy jest zaprojektowanie oraz implementacja emulatora konsoli Game Boy w języku programowania C++, z wykorzystaniem biblioteki Raylib do obsługi warstwy graficznej i wejścia użytkownika. Projekt zakłada odwzorowanie podstawowych mechanizmów działania oryginalnej architektury sprzętowej w stopniu umożliwiającym uruchamianie wybranej klasy gier.

Zakres pracy obejmuje:
\begin{itemize}
	\item implementację emulacji procesora oraz mapy pamięci konsoli,
	\item odwzorowanie mechanizmu wyświetlania obrazu,
	\item obsługę wejścia użytkownika z wykorzystaniem klawiatury,
	\item możliwość wczytywania obrazów ROM typu \textit{ROM Only},
	\item zapewnienie wieloplatformowości (Windows, Linux, macOS).
\end{itemize}

W ramach projektu przyjęto ograniczenie do obsługi podstawowego typu kartridża zawierającego wyłącznie pamięć ROM, bez dodatkowych kontrolerów pamięci (MBC). Emulator przeznaczony jest do uruchamiania cyfrowych kopii gier pozyskanych przez użytkownika z posiadanych nośników.

Poprawność działania systemu zostanie zweryfikowana poprzez porównanie wyników emulacji z publicznie dostępnymi testami zgodności opracowanymi przez społeczność dokumentującą architekturę konsoli.

\subsection{Grupa docelowa}

Odbiorcami opracowanego systemu są użytkownicy posiadający legalne kopie gier przeznaczonych na konsolę Game Boy, zainteresowani ich uruchamianiem na współczesnych komputerach osobistych. Emulator może stanowić również narzędzie edukacyjne dla osób zainteresowanych architekturą systemów wbudowanych oraz mechanizmami niskopoziomowego działania sprzętu.
\section{Analiza architektury systemowej konsoli Game Boy}
\subsection{Specyfikacja techniczna}
Nintendo Research And Development 1, pod przewodnictwem Gunpei Yokoi i Satoru Okady, zaprojektowało 8-bitową konsolę Game Boya. Charakteryzuje się wyświetlaczem matrycowym o rozdzielczości 160x144 pikseli, D-padem, czterema przyciskami gry i jednym głośnikiem. Używa stworzonych na potrzebe konsoli kartridże `GamePak`. Zasilany był przez 4 baterie AA. Gracze mogli korzystać z kabla Game Link Cable do połączenia dwóch Game Boyów dla rozgrywki wieloosobowej bądź transferu danych dla wspierających gier. Chociaż wyświetlacz monochromatyczny był gorszy niż u konkurencji, umożliwił on bardziej tanie i długotrwałe życie baterii. `\cite{wikipedia-gameboy}`
\subsection{Procesor i SoC}
Procesorem Gameboya był specjalnie wytworzyny na potrzeby konsoli  8-bitowy procesor SM83 firmy Sharp. \cite{gbctr}. Procesor był mieszanką dwóch innych procesorów - 8080 firmy Intel i Z80 firmy Zilog. Procesor znajdował się na płytce wraz innymi komponentami takimi jak pamięć RAM i ROM. Cała płytka jest określana jako SoC (System on Chip) i oryginalny Game Boy zawierał DMG-CPU znany także jako Sharp LR35902 \cite{copetti}. SoC był wpinany do płyty głównej, która zawierała dodatkową pamięć RAM i Video RAM (VRAM) jak i łączyła się z innymi kompomentami jak ekran, głośnik czy kontroler. 
\subsubsection{Model czasowy systemu}

Działanie konsoli Game Boy oparte jest na synchronicznym modelu czasowym, w którym wszystkie główne komponenty systemu --- procesor, układ graficzny oraz timery sprzętowe --- pracują w oparciu o wspólne źródło taktowania. Nominalna częstotliwość zegara systemowego wynosi $4{,}194304$~MHz, co determinuje tempo wykonywania instrukcji procesora oraz przebieg cykli pracy pozostałych bloków funkcjonalnych.

\paragraph{Cykle maszynowe procesora}

Procesor wykonuje instrukcje w jednostkach zwanych cyklami maszynowymi (ang. \emph{machine cycles}), z których każdy obejmuje określoną liczbę taktów zegara systemowego. Czas wykonania instrukcji zależy od jej złożoności i wynosi zazwyczaj od jednego do kilku cykli maszynowych. Model czasowy procesora ma charakter deterministyczny, co oznacza, że liczba cykli wymaganych do wykonania danej instrukcji jest stała i niezależna od kontekstu wykonania.

\paragraph{Synchronizacja z układem graficznym}

Układ graficzny pracuje równolegle z procesorem i cyklicznie przechodzi przez zdefiniowane fazy generowania obrazu. Każda ramka obrazu składa się z sekwencji linii skanowania, a przebieg ich przetwarzania wyznacza rytm pracy całego systemu. W określonych fazach generowania obrazu dostęp procesora do wybranych obszarów pamięci wideo jest ograniczony, co stanowi bezpośrednią konsekwencję współdzielenia zasobów pamięci pomiędzy jednostkami systemu.

\paragraph{System timerów sprzętowych}

Konsola wyposażona jest w sprzętowe układy odmierzania czasu, których działanie jest bezpośrednio powiązane z zegarem systemowym. Timery te generują zdarzenia okresowe wykorzystywane do synchronizacji logiki programu, pomiaru czasu oraz inicjowania przerwań sprzętowych. Ich konfiguracja pozwala na wybór różnych częstotliwości zliczania poprzez dzielenie sygnału zegarowego.

\paragraph{Znaczenie modelu czasowego}

Ścisłe powiązanie pracy wszystkich komponentów z jednym źródłem taktowania zapewnia deterministyczny charakter działania systemu. W konsekwencji poprawność działania oprogramowania zależy nie tylko od sekwencji wykonywanych instrukcji, lecz również od ich dokładnego rozmieszczenia w czasie względem zdarzeń sprzętowych. Model czasowy stanowi zatem istotny element architektury systemowej konsoli i odgrywa kluczową rolę w implementacji wiernych emulatorów platformy.
%
Procesor zawiera osiem 8-bitowych rejestrów: A,B,C,D,E,F,H,L. Rejestry mogą łączyć się w 16-bitowe rejestry: AF, BC, DE, HL . Rejestr F jest używany jako flagi procesora w wypadku operacji arymetycznych:
\begin{itemize}
	\item Bit 7 - Zero (Z), jeśli operacja zwróciła zero
	\item Bit 6 -  Negacja (N), używana gdy ostatnia operacją była porównaniem bądź odejmowaniem
	\item Bit 5 - Half Carry (H), jeśli doszło do przesunięcia na bicie 3
	\item Bit 4 - Carry (C), jeśli doszło do przesunięcia na bicie 7
\end{itemize} 

Bity od 3 do 0 są nieużywane i zawsze powinny być zerowane. Rejestr A jest używany jako akumulator w operacja arytmetcznych.

\subsection{Zestaw Instrukcji}

Zestaw rozkazów (instruction set architecture, ISA) stanowi rozwinięcie koncepcji znanych z mikroprocesorów rodziny Z80, z licznymi uproszczeniami i modyfikacjami dostosowanymi do zastosowań w systemie przenośnym. Wszytkie rozkazy można systematycznie sklasyfikować na poszczególne grupy .

\begin{figure}[htbp]
	\centering
	\begin{minipage}{0.9\textwidth}
		\centering
		\includegraphics[width=0.9\linewidth]{gbobtables.png}
		\caption{Tablica rozmieszczenia instrukcji: \cite{opcodes}}
		\label{fig:op_table}
	\end{minipage}
	\hfill
	\begin{minipage}{0.9\textwidth}
		\centering
		\includegraphics[width=0.9\linewidth]{gbobtables_cb.png}
		\caption{Tablica rozmieszczenia instrukcji po opcodzie 0xCB: \cite{opcodes}}
		\label{fig:opcb_table}
	\end{minipage}
\end{figure}

\subsubsection{Instrukcje transferu danych}

Instrukcje tej grupy odpowiadają za przemieszczanie informacji pomiędzy rejestrami, pamięcią oraz natychmiastowymi wartościami liczbowymi. Do najważniejszych operacji należą:

\begin{itemize}
	\item \textbf{LD (Load)} -- realizuje kopiowanie danych pomiędzy rejestrami ogólnego przeznaczenia (A, B, C, D, E, H, L), parami rejestrów oraz komórkami pamięci adresowanymi bezpośrednio lub pośrednio.
	\item \textbf{LDH} -- specjalizowana forma transferu do i z obszaru pamięci o wysokim adresie (High RAM).
	\item \textbf{PUSH / POP} -- zapis i odczyt danych na stosie, z wykorzystaniem wskaźnika stosu SP.
\end{itemize}

Instrukcje transferu nie modyfikują danych źródłowych (z wyjątkiem operacji stosowych), a ich podstawową funkcją jest reorganizacja informacji w przestrzeni rejestrowo-pamięciowej procesora.

\subsubsection{Instrukcje arytmetyczne}

Instrukcje arytmetyczne realizują operacje matematyczne na liczbach całkowitych. W SM83 operacje te wykonywane są głównie na akumulatorze A. Do kluczowych operacji należą:

\begin{itemize}
	\item \textbf{ADD / ADC} -- dodawanie bez i z uwzględnieniem flagi przeniesienia,
	\item \textbf{SUB / SBC} -- odejmowanie bez i z uwzględnieniem przeniesienia,
	\item \textbf{INC / DEC} -- inkrementacja i dekrementacja rejestrów oraz komórek pamięci,
	\item \textbf{DAA} -- korekcja wyniku dodawania do postaci BCD,
	\item \textbf{CP} -- porównanie wartości bez zapisu wyniku (modyfikowane są jedynie flagi).
\end{itemize}

Instrukcje te aktualizują rejestr flag (Z, N, H, C), który odzwierciedla właściwości wyniku operacji.

\subsubsection{Instrukcje logiczne i bitowe}

Grupa ta obejmuje operacje algebry Boole’a oraz manipulacje pojedynczymi bitami. Do najważniejszych należą:

\begin{itemize}
	\item \textbf{AND, OR, XOR} -- operacje logiczne na akumulatorze,
	\item \textbf{CPL} -- negacja bitowa zawartości akumulatora,
	\item \textbf{BIT} -- test wybranego bitu,
	\item \textbf{SET / RES} -- ustawienie lub wyzerowanie wskazanego bitu.
\end{itemize}

Instrukcje bitowe umożliwiają precyzyjną kontrolę struktur danych, co jest szczególnie istotne w systemach o ograniczonych zasobach pamięci.

\subsubsection{Instrukcje przesunięć i rotacji}

Operacje tej kategorii realizują przesunięcia bitowe oraz rotacje z lub bez udziału flagi przeniesienia:

\begin{itemize}
	\item \textbf{RL, RLC} -- rotacja w lewo,
	\item \textbf{RR, RRC} -- rotacja w prawo,
	\item \textbf{SLA, SRA, SRL} -- przesunięcia arytmetyczne i logiczne,
	\item \textbf{SWAP} -- zamiana półbajtów w rejestrze.
\end{itemize}

Instrukcje te są użyteczne zarówno w obliczeniach arytmetycznych, jak i w przetwarzaniu danych binarnych.

\subsubsection{Instrukcje sterowania przepływem programu}

Instrukcje sterujące odpowiadają za zmianę kolejności wykonywania programu:

\begin{itemize}
	\item \textbf{JP} -- skok bezwarunkowy lub warunkowy,
	\item \textbf{JR} -- skok względny o ograniczonym zasięgu,
	\item \textbf{CALL / RET} -- wywołanie i powrót z podprogramu,
	\item \textbf{RST} -- szybkie wywołanie procedury o stałym adresie.
\end{itemize}

Warunkowość operacji zależy od stanu flag procesora, co umożliwia implementację struktur decyzyjnych.

Do tej grupy należą instrukcje wpływające na stan globalny procesora:

\begin{itemize}
	\item \textbf{NOP} -- brak operacji,
	\item \textbf{HALT} -- zatrzymanie pracy CPU do momentu wystąpienia przerwania,
	\item \textbf{STOP} -- tryb niskiego poboru energii,
	\item \textbf{DI / EI} -- dezaktywacja i aktywacja systemu przerwań,
	\item \textbf{SCF / CCF} -- manipulacja flagą przeniesienia.
\end{itemize}

Instrukcje te mają kluczowe znaczenie dla zarządzania energią oraz obsługi zdarzeń asynchronicznych.


\subsection{Mapowanie pamięci w konsoli Game Boy}

Architektura pamięci konsoli Game Boy oparta jest na 16-bitowej przestrzeni adresowej o rozmiarze $2^{16} = 65\,536$ bajtów (64~KB). Procesor systemu, zgodny z modyfikowaną architekturą Sharp LR35902, wykorzystuje jednolitą przestrzeń adresową, w której różne zakresy adresów są przypisane do odmiennych typów pamięci oraz rejestrów sprzętowych. Taki model organizacji pamięci określany jest jako \emph{memory-mapped I/O} i umożliwia bezpośrednią komunikację procesora z układami peryferyjnymi poprzez operacje odczytu i zapisu w odpowiednich obszarach adresowych.

\subsubsection{Ogólny układ przestrzeni adresowej}

Przestrzeń adresowa Game Boya podzielona jest na segmenty o ustalonej funkcji sprzętowej. Tabela~\ref{tab:gb_memory_map} przedstawia standardowy schemat mapowania pamięci.

\begin{table}[h]
	\centering
	\begin{tabular}{lll}
		\hline
		Zakres adresów & Rozmiar & Przeznaczenie \\
		\hline
		\texttt{0000--3FFF} & 16 KB & Stała pamięć ROM banku 0 \\
		\texttt{4000--7FFF} & 16 KB & Przełączalny bank ROM \\
		\texttt{8000--9FFF} & 8 KB  & Pamięć wideo (VRAM) \\
		\texttt{A000--BFFF} & 8 KB  & Zewnętrzna pamięć RAM w kartridżu \\
		\texttt{C000--CFFF} & 4 KB  & Wewnętrzna pamięć robocza (WRAM bank 0) \\
		\texttt{D000--DFFF} & 4 KB  & Wewnętrzna pamięć robocza (bank przełączalny) \\
		\texttt{E000--FDFF} & 7.5 KB & Obszar echo pamięci WRAM \\
		\texttt{FE00--FE9F} & 160 B & Pamięć atrybutów obiektów (OAM) \\
		\texttt{FEA0--FEFF} & 96 B  & Obszar niedostępny \\
		\texttt{FF00--FF7F} & 128 B & Rejestry wejścia/wyjścia \\
		\texttt{FF80--FFFE} & 127 B & Pamięć szybka (HRAM) \\
		\texttt{FFFF}       & 1 B   & Rejestr przerwań (IE) \\
		\hline
	\end{tabular}
	\caption{Mapa pamięci konsoli Game Boy \cite{pandocs}}
	\label{tab:gb_memory_map}
\end{table}

\subsubsection{Pamięć programu i bankowanie ROM}

Dolne 32~KB przestrzeni adresowej przeznaczone jest na pamięć tylko do odczytu (ROM) zawartą w kartridżu. Pierwsze 16~KB (\texttt{0000--3FFF}) stanowi bank stały, natomiast zakres \texttt{4000--7FFF} obsługuje mechanizm przełączania banków pamięci, realizowany przez kontroler MBC (Memory Bank Controller). Dzięki temu możliwe jest adresowanie programów o rozmiarze znacznie przekraczającym 64~KB.

\subsubsection{Pamięć wideo}

Obszar \texttt{8000--9FFF} odpowiada pamięci VRAM, wykorzystywanej przez układ graficzny do przechowywania danych kafelków graficznych oraz map tła. Dostęp do tej pamięci jest ograniczony w określonych fazach cyklu wyświetlania obrazu, co wynika z synchronizacji procesora z kontrolerem LCD.

\subsubsection{Pamięć robocza i obszar echo}

Wewnętrzna pamięć robocza WRAM zajmuje zakres \texttt{C000--DFFF}. Dodatkowo obszar \texttt{E000--FDFF} stanowi tzw. echo WRAM, czyli lustrzane odwzorowanie części pamięci roboczej. Jego obecność wynika z uproszczeń sprzętowych i nie jest zalecana do programowego wykorzystania.

\subsubsection{Mapowanie urządzeń wejścia/wyjścia}

Zakres \texttt{FF00--FF7F} zawiera rejestry sterujące sprzętem, w tym kontrolerem dźwięku, systemem przerwań, timerami oraz interfejsem wejściowym. Operacje zapisu i odczytu w tych adresach odpowiadają bezpośrednim operacjom na urządzeniach peryferyjnych.

\subsubsection{Pamięć wysokiej prędkości}

Obszar \texttt{FF80--FFFE}, określany jako HRAM (High RAM), to niewielki fragment szybkiej pamięci roboczej o krótkim czasie dostępu. Ze względu na swoje właściwości jest on często wykorzystywany do przechowywania zmiennych o krytycznym znaczeniu czasowym.

\subsubsection{Znaczenie architektury mapowania pamięci}

Przyjęty model mapowania pamięci umożliwia efektywne współdzielenie przestrzeni adresowej przez kod programu, dane oraz układy sprzętowe. Rozwiązanie to upraszcza konstrukcję systemu, lecz jednocześnie wymaga ścisłej kontroli dostępu do poszczególnych segmentów pamięci przez oprogramowanie systemowe i aplikacyjne.
\subsection{System przerwań w konsoli Game Boy}

System przerwań w konsoli Game Boy realizuje mechanizm asynchronicznej obsługi zdarzeń sprzętowych, umożliwiając procesorowi reagowanie na zdarzenia wewnętrzne i zewnętrzne bez konieczności ciągłego odpytywania urządzeń peryferyjnych. Architektura ta stanowi kluczowy element synchronizacji pracy jednostki centralnej z układami graficznymi, licznikami czasu oraz interfejsem wejściowym.

\subsubsection{Źródła przerwań}

Konsola Game Boy obsługuje pięć podstawowych źródeł przerwań sprzętowych. Każdemu z nich przypisany jest odrębny wektor przerwania oraz odpowiedni bit w rejestrach sterujących. Zestaw źródeł przerwań przedstawiono w tabeli~\ref{tab:gb_interrupts}.

\begin{table}[h]
	\centering
	\begin{tabular}{lll}
		\hline
		Bit & Nazwa przerwania & Funkcja \\
		\hline
		0 & V-Blank & Zakończenie rysowania ramki obrazu \\
		1 & LCD STAT & Zdarzenia kontrolera LCD \\
		2 & Timer & Przepełnienie timera systemowego \\
		3 & Serial & Zakończenie transmisji szeregowej \\
		4 & Joypad & Zmiana stanu kontrolera wejściowego \\
		\hline
	\end{tabular}
	\caption{Źródła przerwań w konsoli Game Boy}
	\label{tab:gb_interrupts}
\end{table}

Przerwanie V-Blank pełni szczególną rolę, ponieważ wyznacza bezpieczny moment aktualizacji pamięci wideo. Przerwanie LCD STAT umożliwia reakcję na szczegółowe stany pracy kontrolera wyświetlania, natomiast przerwanie timera wykorzystywane jest do odmierzania czasu oraz synchronizacji logiki programu.

\subsubsection{Rejestry sterujące systemem przerwań}

Obsługa przerwań realizowana jest poprzez dwa rejestry mapowane w przestrzeni adresowej:

\begin{itemize}
	\item \texttt{IE} (Interrupt Enable, adres \texttt{FFFF}) --- określa, które źródła przerwań są aktywne.
	\item \texttt{IF} (Interrupt Flag, adres \texttt{FF0F}) --- przechowuje informację o zgłoszonych przerwaniach.
\end{itemize}

Każdy bit w obu rejestrach odpowiada jednemu źródłu przerwania. Zgłoszenie przerwania polega na ustawieniu odpowiedniego bitu w rejestrze \texttt{IF}. Jeżeli odpowiadający mu bit w rejestrze \texttt{IE} jest ustawiony oraz globalna obsługa przerwań jest włączona, procesor inicjuje procedurę obsługi przerwania.

\subsubsection{Mechanizm obsługi przerwania}

Po wykryciu aktywnego przerwania procesor wykonuje następującą sekwencję działań:

\begin{enumerate}
	\item zakończenie bieżącej instrukcji,
	\item zapis aktualnej wartości licznika programu na stosie,
	\item wyłączenie globalnej obsługi przerwań,
	\item skok pod adres wektora przerwania.
\end{enumerate}

Adresy wektorów przerwań są stałe i przypisane do konkretnych źródeł zdarzeń. Po zakończeniu procedury obsługi przerwania wykonywana jest instrukcja powrotu, która przywraca poprzedni stan wykonania programu.

\subsubsection{Priorytety przerwań}

W przypadku jednoczesnego zgłoszenia wielu przerwań stosowany jest ustalony porządek priorytetów. Najwyższy priorytet posiada przerwanie V-Blank, a najniższy przerwanie kontrolera wejściowego. Taki schemat zapewnia deterministyczną obsługę zdarzeń związanych z generowaniem obrazu, które są krytyczne dla poprawnego działania systemu.

\subsubsection{Rola systemu przerwań w architekturze konsoli}

System przerwań stanowi podstawowy mechanizm synchronizacji komponentów sprzętowych konsoli Game Boy. Dzięki niemu możliwe jest efektywne współdziałanie procesora z kontrolerem graficznym, licznikami czasu oraz urządzeniami wejścia/wyjścia przy zachowaniu deterministycznego modelu wykonania programu. Mechanizm ten ma istotne znaczenie zarówno dla projektowania oprogramowania systemowego, jak i dla implementacji emulatorów platformy.

\subsection{Płyta główna}

Płyta główna konsoli Game Boy stanowi podstawowy element konstrukcyjny systemu, integrujący wszystkie kluczowe układy elektroniczne odpowiedzialne za przetwarzanie danych, generowanie obrazu, obsługę dźwięku oraz zarządzanie energią. Ze względu na przenośny charakter urządzenia, konstrukcja płyty została zaprojektowana z naciskiem na energooszczędność, prostotę architektury oraz wysoką niezawodność.

\begin{figure}[htbp]
	\centering
	\begin{minipage}{0.45\textwidth}
		\centering
		\includegraphics[width=0.9\linewidth]{dmg_marked.png}
		\caption{Zdjęcie płyty głównej oryginalnego GameBoy'a z opisami kompomentów}
		\label{fig:marked_dmg}
	\end{minipage}
	\hfill
	\begin{minipage}{0.45\textwidth}
		\centering
		\includegraphics[width=0.9\linewidth]{dmg_chart.png}
		\caption{Schemat płyty głównej konsoli GameBoy}
		\label{fig:chart_dmg}
	\end{minipage}
	\caption{Źródło: \cite{copetti}}
\end{figure}

\subsubsection{Jednostka centralna}

Centralnym elementem płyty głównej jest układ DMG-CPU, stanowiący zintegrowany system typu System on Chip (SoC). W przeciwieństwie do klasycznych konstrukcji mikrokomputerowych, w których poszczególne funkcje realizowane są przez oddzielne układy scalone, DMG-CPU integruje w jednej strukturze półprzewodnikowej jednostkę obliczeniową, kontroler pamięci, układ graficzny, generator dźwięku oraz logikę sterującą systemem.

Rdzeń obliczeniowy układu bazuje na architekturze 8-bitowej z 16-bitową przestrzenią adresową i realizuje wykonywanie programu oraz zarządzanie przepływem danych pomiędzy komponentami systemu. Integracja funkcji w jednym układzie pozwoliła na ograniczenie liczby połączeń na płycie głównej, zmniejszenie poboru energii oraz zwiększenie niezawodności urządzenia.

DMG-CPU odpowiada również za synchronizację pracy podsystemów, obsługę przerwań sprzętowych, sterowanie dostępem do pamięci operacyjnej i wideo oraz koordynację komunikacji z interfejsem kartridża i urządzeniami wejścia-wyjścia. Zastosowanie architektury SoC stanowiło kluczowy element miniaturyzacji konsoli oraz umożliwiło osiągnięcie wysokiej efektywności energetycznej przy zachowaniu pełnej funkcjonalności systemu.


\subsubsection{Pamięć operacyjna i pamięć wideo}

Na płycie głównej znajdują się układy pamięci pełniące różne funkcje w architekturze systemu:

\begin{itemize}
	\item \textbf{WRAM (Work RAM)} -- pamięć operacyjna wykorzystywana przez procesor do przechowywania danych roboczych oraz stosu.
	\item \textbf{VRAM (Video RAM)} -- pamięć przeznaczona do przechowywania danych graficznych, takich jak mapy kafli, wzorce znaków oraz informacje o sprite’ach.
\end{itemize}

Pamięci te współpracują bezpośrednio z procesorem oraz układem generowania obrazu, zapewniając sprawną wymianę danych niezbędnych do działania systemu.

\subsubsection{Układ graficzny}

Funkcje generowania obrazu realizowane są przez zintegrowany kontroler LCD, który odpowiada za przetwarzanie danych graficznych i sterowanie wyświetlaczem ciekłokrystalicznym. Układ ten obsługuje system kafli (tile-based graphics), renderowanie sprite’ów oraz synchronizację obrazu z odświeżaniem ekranu. Kontroler LCD współpracuje bezpośrednio z pamięcią wideo oraz procesorem, tworząc kompletny tor przetwarzania grafiki.

\subsubsection{Układ dźwiękowy}

System dźwiękowy konsoli jest zintegrowany z architekturą płyty głównej i składa się z generatorów fal dźwiękowych sterowanych programowo. Układ ten umożliwia generowanie kilku kanałów audio, w tym fal prostokątnych, szumu oraz próbek o ograniczonej rozdzielczości. Sygnał audio kierowany jest następnie do wzmacniacza i głośnika lub wyjścia słuchawkowego. Ze względu skomplikowania, kompoment układu dźwiękowego nie będzie uwzględniany

\subsubsection{Interfejs kartridża}

Na płycie głównej znajduje się złącze kartridża umożliwiające komunikację z zewnętrznym nośnikiem oprogramowania. Interfejs ten zapewnia:

\begin{itemize}
	\item dostęp do pamięci programu,
	\item komunikację z dodatkowymi układami w kartridżu,
	\item możliwość rozszerzenia funkcjonalności systemu.
\end{itemize}

Zastosowanie wymiennych kartridży umożliwiło modularną architekturę systemu oraz łatwą dystrybucję oprogramowania.

\subsubsection{Układy wejścia i wyjścia}

Płyta główna integruje również komponenty odpowiedzialne za komunikację z użytkownikiem oraz otoczeniem:

\begin{itemize}
	\item kontroler przycisków sterujących,
	\item interfejs komunikacyjny (port szeregowy),
	\item sterowanie wyświetlaczem LCD,
	\item wzmacniacz audio.
\end{itemize}

Układy te zapewniają interakcję użytkownika z systemem oraz obsługę sygnałów wejściowych i wyjściowych.

Płyta główna konsoli Game Boy stanowi przykład zwartej i funkcjonalnej integracji elementów elektronicznych w systemie o ograniczonych zasobach sprzętowych. Zastosowanie zintegrowanych układów scalonych, zoptymalizowane zarządzanie energią oraz modułowa struktura pamięci i interfejsów umożliwiły stworzenie wydajnego, przenośnego systemu rozrywkowego. Analiza budowy płyty głównej pozwala dostrzec kompromis pomiędzy funkcjonalnością, energooszczędnością a prostotą konstrukcji, charakterystyczny dla projektowania urządzeń przenośnych końca XX wieku.

\subsection{Kartridże systemu Game Boy}

Kartridże stanowią podstawowy nośnik oprogramowania dla konsoli Game Boy oraz element rozszerzający funkcjonalność systemu. Oprócz pamięci programu zawierają one układy logiczne odpowiedzialne za zarządzanie pamięcią, zapisywanie danych użytkownika oraz, w niektórych przypadkach, dodatkowe funkcje sprzętowe. Różnorodność konstrukcji kartridżów wynikała z konieczności obsługi gier o rosnącej złożoności przy zachowaniu ograniczeń architektury systemu.

\subsubsection{Kartridże bez kontrolera banków pamięci (ROM Only)}

Najprostszy typ kartridża zawiera wyłącznie pamięć ROM z programem gry. Konstrukcja ta nie umożliwia przełączania banków pamięci ani zapisu danych użytkownika. Ze względu na ograniczoną pojemność stosowana była głównie w prostszych produkcjach we wczesnym okresie rozwoju systemu.

\subsubsection{Kartridże z kontrolerem MBC1}

Kontroler Memory Bank Controller 1 (MBC1) umożliwia przełączanie banków pamięci ROM oraz, opcjonalnie, banków pamięci RAM. Układ ten pozwalał na znaczące zwiększenie maksymalnego rozmiaru programu. Kartridże tego typu występowały w kilku wariantach:

\begin{itemize}
	\item MBC1 + RAM,
	\item MBC1 + RAM + bateria podtrzymująca zapis danych.
\end{itemize}

\subsubsection{Kartridże z kontrolerem MBC2}

MBC2 integruje funkcję przełączania banków ROM z niewielką, wbudowaną pamięcią RAM przeznaczoną do zapisu danych gry. W odróżnieniu od innych kontrolerów, pamięć RAM jest integralną częścią układu i nie występuje jako oddzielny komponent. Kartridże te standardowo wyposażone były w baterię podtrzymującą zapis.

\subsubsection{Kartridże z kontrolerem MBC3}

MBC3 rozszerza funkcjonalność poprzednich kontrolerów o zegar czasu rzeczywistego (RTC). Rozwiązanie to umożliwiało implementację mechanik zależnych od upływu czasu rzeczywistego. Warianty konstrukcyjne obejmowały:

\begin{itemize}
	\item MBC3 + RAM,
	\item MBC3 + RAM + bateria,
	\item MBC3 + RAM + bateria + RTC.
\end{itemize}

\subsubsection{Kartridże z kontrolerem MBC5}

MBC5 wprowadza rozszerzony system adresowania pamięci ROM oraz obsługę większych pojemności pamięci RAM. Układ ten był stosowany w późniejszych produkcjach o dużej objętości danych. Warianty obejmowały:

\begin{itemize}
	\item MBC5 + RAM,
	\item MBC5 + RAM + bateria,
	\item MBC5 + RAM + bateria + silnik wibracyjny (Rumble).
\end{itemize}

\subsubsection{Kartridże specjalizowane}

Oprócz standardowych kontrolerów banków pamięci produkowano kartridże wyposażone w dodatkowe układy funkcjonalne rozszerzające możliwości systemu. Do najważniejszych należą:

\begin{itemize}
	\item kartridże z czujnikiem ruchu,
	\item kartridże z pamięcią EEPROM,
	\item kartridże z dodatkowymi układami logicznymi sterującymi akcesoriami,
	\item kartridże diagnostyczne i testowe wykorzystywane w procesie produkcyjnym.
\end{itemize}

\subsubsection{Struktura fizyczna kartridża}

Typowy kartridż składa się z płytki drukowanej zawierającej układ ROM, opcjonalną pamięć RAM, kontroler banków pamięci oraz element podtrzymania zasilania pamięci zapisu. Komunikacja z konsolą odbywa się za pośrednictwem złącza krawędziowego, które zapewnia dostęp do magistrali adresowej, magistrali danych oraz linii sterujących.



\printbibliography
	

\end{document}
